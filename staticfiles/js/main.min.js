(function () { 'use strict'; const form = document.getElementById('generator-form'), generateBtn = document.getElementById('generate-btn'), outputContainer = document.getElementById('output-container'), headcanonList = document.getElementById('headcanon-list'), characterOutput = document.getElementById('character-output'), copyBtn = document.getElementById('copy-btn'), regenerateBtn = document.getElementById('regenerate-btn'), themeToggle = document.getElementById('theme-toggle'); let lastRequest = null, isGenerating = false; function initTheme() { const saved = localStorage.getItem('theme') || 'light'; document.documentElement.setAttribute('data-theme', saved); updateThemeIcon(saved) } function toggleTheme() { const current = document.documentElement.getAttribute('data-theme'); const next = current === 'dark' ? 'light' : 'dark'; document.documentElement.setAttribute('data-theme', next); localStorage.setItem('theme', next); updateThemeIcon(next) } function updateThemeIcon(theme) { if (themeToggle) { themeToggle.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™'; themeToggle.setAttribute('aria-label', theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode') } } function initFAQ() { const faqItems = document.querySelectorAll('.faq-item'); faqItems.forEach(item => { const question = item.querySelector('.faq-question'); question.addEventListener('click', () => { const isActive = item.classList.contains('active'); faqItems.forEach(i => { i.classList.remove('active'); const btn = i.querySelector('.faq-question'); if (btn) btn.setAttribute('aria-expanded', 'false') }); if (!isActive) { item.classList.add('active'); question.setAttribute('aria-expanded', 'true') } }) }) } async function generateHeadcanons(characterName, fandom, tone) { if (isGenerating) return; isGenerating = true; const btnText = generateBtn.querySelector('.btn-text'), btnLoading = generateBtn.querySelector('.btn-loading'); btnText.style.display = 'none'; btnLoading.style.display = 'inline'; generateBtn.disabled = true; try { const response = await fetch('/api/generate/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ character: characterName, fandom: fandom, tone: tone }) }); const data = await response.json(); if (data.success) { displayHeadcanons(data.headcanons, data.character); lastRequest = { character: characterName, fandom, tone } } else { showError(data.error || 'Failed to generate headcanons') } } catch (error) { console.error('Error:', error); showError('Network error. Please try again.') } finally { btnText.style.display = 'inline'; btnLoading.style.display = 'none'; generateBtn.disabled = false; isGenerating = false } } function displayHeadcanons(headcanons, characterName) { headcanonList.innerHTML = ''; characterOutput.textContent = characterName; headcanons.forEach((headcanon, index) => { const li = document.createElement('li'); li.textContent = headcanon; li.style.animationDelay = `${index * 0.1}s`; li.classList.add('fade-in'); headcanonList.appendChild(li) }); outputContainer.style.display = 'block'; outputContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' }) } function showError(message) { headcanonList.innerHTML = `<li style="border-left-color:#ef4444;">${message}</li>`; characterOutput.textContent = 'Error'; outputContainer.style.display = 'block' } async function copyHeadcanons() { const headcanons = Array.from(headcanonList.querySelectorAll('li')).map(li => 'â€¢ ' + li.textContent).join('\n'); const character = characterOutput.textContent; const text = `Headcanons for ${character}:\n\n${headcanons}\n\nâ€” Generated at headcanongenerator.world`; try { await navigator.clipboard.writeText(text); copyBtn.innerHTML = 'âœ“ Copied!'; copyBtn.classList.add('copied'); setTimeout(() => { copyBtn.innerHTML = 'ðŸ“‹ Copy'; copyBtn.classList.remove('copied') }, 2000) } catch (err) { const textarea = document.createElement('textarea'); textarea.value = text; textarea.style.position = 'fixed'; textarea.style.opacity = '0'; document.body.appendChild(textarea); textarea.select(); document.execCommand('copy'); document.body.removeChild(textarea); copyBtn.innerHTML = 'âœ“ Copied!'; copyBtn.classList.add('copied'); setTimeout(() => { copyBtn.innerHTML = 'ðŸ“‹ Copy'; copyBtn.classList.remove('copied') }, 2000) } } function regenerate() { if (lastRequest) { generateHeadcanons(lastRequest.character, lastRequest.fandom, lastRequest.tone) } } function handleSubmit(e) { e.preventDefault(); const characterName = document.getElementById('character-name').value.trim(); if (!characterName) { document.getElementById('character-name').focus(); return } const fandomSelect = document.getElementById('fandom-select').value; const fandomCustom = document.getElementById('fandom-custom').value.trim(); const fandom = fandomCustom || fandomSelect || ''; const toneRadio = document.querySelector('input[name="tone"]:checked'); const tone = toneRadio ? toneRadio.value : 'random'; generateHeadcanons(characterName, fandom, tone) } function initSmoothScroll() { document.querySelectorAll('a[href^="#"]').forEach(anchor => { anchor.addEventListener('click', function (e) { const href = this.getAttribute('href'); if (href === '#') return; const target = document.querySelector(href); if (target) { e.preventDefault(); target.scrollIntoView({ behavior: 'smooth' }) } }) }) } function init() { initTheme(); if (form) { form.addEventListener('submit', handleSubmit) } if (copyBtn) { copyBtn.addEventListener('click', copyHeadcanons) } if (regenerateBtn) { regenerateBtn.addEventListener('click', regenerate) } if (themeToggle) { themeToggle.addEventListener('click', toggleTheme) } initFAQ(); initSmoothScroll() } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init) } else { init() } })();
